1. **extern "C"**  
   - extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。加上extern "C"后，会指示编译器这部分代码按C语言（而不是C++）的方式进行编译。由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般只包括函数名。  
   补充：语句：extern int a; 仅仅是一个变量的声明，其并不是在定义变量a，也并未为a分配空间。变量a在所有模块中作为一种全局变量只能被定义一次，否则会出错。
2. **有几种构造函数**
   - 默认构造函数
   - 拷贝构造函数
   - 一般带参数的初始化构造函数,单个参数隐式转化,explicit
   - 移动构造函数：利用右值引用进行浅拷贝，避免深拷贝临时对象时申请额外的空间
   - 继承构造函数：*using Base::Base* (Base为基类及其构造函数)
   - 委托构造函数
3. **结构体内存对齐**
   - 内存对齐的意义：大部分处理器并不是按字节块来存取内存的，它一般会以双字节,四字节,8字节,16字节甚至32字节为单位来存取内存，如果没有内存对齐，数据可以任意存放，CPU存取数据要做许多额外工作。内存对齐相当于以空间换时间。
   - 有效对齐值：是给定值#pragma pack(n)和结构体中最长数据类型长度中较小的那个。有效对齐值也叫对齐单位。
   - 结构体第一个成员的偏移量（offset）为0，以后每个成员相对于结构体首地址的 offset 都是该成员大小与有效对齐值中较小那个的整数倍，如有需要编译器会在成员之间加上填充字节。
   - 结构体的总大小为 有效对齐值 的整数倍，如有需要编译器会在最末一个成员之后加上填充字节。
   - 嵌套的结构体起始位置为：嵌套结构体的有效对齐值的整数倍。
4. **内存栈与堆**
   - 管理方式不同：栈，由编译器自动管理；堆，产生和释放由程序员控制。
   - 分配方式不同：堆是动态分配的。栈可以是静态分配和动态分配（alloca函数）两种，但是栈的动态分配由编译器释放。
   - 分配效率不同：栈快，堆慢。
   - 空间大小不同：栈空间小，堆较大。
   - 能否产生碎片不同：栈不产生，堆产生。
   - 生长方向不同：栈向下，堆向上.
5. **虚函数如何实现多态**
   - 具有虚函数的基类和派生类含有一个虚函数表，保存虚函数的指针，一个类只有一个虚函数表。
   - 类的对象内部有一个指向自己所属类的虚函数表的指针。
   - 虚表中的指针会指向其继承的最近的一个类的虚函数，或者自己重写的虚函数。
   - 我们把经过虚表调用虚函数的过程称为动态绑定，其表现出来的现象称为运行时多态。
   - 基类指针指向派生类对象时，会指向派生类的虚函数表。（特殊）  
   <br/>
6. **define和const的区别**
   - 编译器处理时间：define是在预编译时处理的，const则是在编译运行时处理的。
   - 编译器处理方式：对于define编译器每次处理时只是简单的做替换，不会做类型检测，可能会有安全隐患，并且每次替换都会重新分配内存；对于const编译器会编译检查，会报编译错误，const常量在常量内存区中存储，至始至终只会占用一份内存，不会像define那样每次替换都会重新分配内存。
   - 数据类型：define 没有明确的数据类型，而const必须要指定数据类型
   - define优点：可以宏定义函数,const优点：const常量可以调试，而define常量不能调试。
7. **static,extern**
   - 静态数据成员，必须初始化，而且只能在类体外进行。
   - 静态成员函数，没有this指针，只能调用静态数据成员和静态成员函数。
   - 静态全局变量，不能被外部文件使用（include进来的文件不属于外部文件）。
   - 静态局部变量，不随作用域结束而销毁。
   - 静态非成员函数，与静态全局变量类似，不能被外部文件使用。
   - 通常来说，在模块的头文件中对本模块提供给其他模块引用的函数和全局变量,在其他文件中以关键字extern声明。例如，模块B包含模块A的头文件，而模块A要使用模块B的全局变量需要以extern声明。这样在编译阶段，模块A虽然找不到该变量，但并不会报错；它会在链接阶段从模块B编译生成的目标代码中找到该变量。extern对应的关键字是static，static表明变量或者函数只能在本模块中使用，因此，被static修饰的变量或者函数不可能被extern修饰。
8. **c++编译过程**
   - 预处理（得到.i文件）：预处理又称为预编译，是做些代码文本替换工作。编译器执行预处理指令（以#开头，例如#include），这个过程会得到不包含#指令的.i文件。这个过程会拷贝#include包含的文件代码，进行#define 宏定义的替换，处理条件编译指令 （#ifndef #ifdef #endif）等。
   - 编译及优化（得到.s文件）：这阶段要做的工作主要是，通过语法分析和词法分析，确定所有指令是否符合规则，之后翻译成汇编代码。
   - 汇编（得到.obj或.o文件）：汇编过程就是把汇编语言翻译成目标机器指令的过程，生成目标文件（二进制文件）。
   - 链接：链接过程将多个目标文件以及所需的库文件(.so等)链接成最终的可执行文件
9.  **vector底层原理**
    - 内部定义了三个指针，_Myfirst 指向的是 vector 容器对象的起始字节位置,_Mylast 指向当前最后一个元素的末尾字节,_Myend 指向整个 vector 容器所占用内存空间的末尾字节;利用者三个指针组合出不同的函数功能。
    - 扩大容量步骤：重新申请更大的内存空间；将旧内存空间中的数据，按原有顺序移动到新的内存空间中；最后将旧的内存空间释放。 
10. **各种智能指针，shared_ptr,weak_ptr,unique_ptr**
    - shared_ptr:带有计数器，计算指向当前对象的指针个数,会发生增减，当计数为1且跳出当前作用域时，自动delete。
    - weak_ptr:不能操作数据，不增减计数器，作为shared_ptr的补充解决循环引用问题（详述）。
    - unique_ptr:独占一个对象，一个对象生命周期内只能被一个unique_ptr指向。
      - unique_ptr<T> u1
      - u1.release():
        - 返回u1所拥有内存的内置指针；
        - 将u1置空，但不释放内存。
      - u1.reset(p):
        - 若u1不为空，释放原来指向的对象；
        - p参数可选，是内置指针类型，将u1指向p指向的内存；
        - 若无参数，则释放对象后置空。
      - 为什么不能拷贝初始化：没有一般意义的拷贝构造函数，且单参数构造函数是explict的，即explicit unique_ptr(pointer p)，不能隐式转换只能直接初始化。
      - 为什么可以拷贝即将销毁的unique_ptr：调用了std::move()将之转化为右值，并执行非explict的移动构造， 即             unique_ptr(unique_ptr&& u)。
      - 若要进行赋值，则调用std::move()将之转化为右值，并执行重载的赋值运算符，即unique_ptr& opertor=(unique_ptr&& r)。
    - auto_ptr：=运算符执行所有权转移，而在unique_ptr中需要使用std::move()转为右值后移动拷贝 或 调用函数显式转移，         如：u1.reset(u2.release());
11. **平衡二叉树（AVL）**
    - 平衡二叉树（AVL）：是二叉查找树；左右子树都是AVL,且高度差不超过1。
12. **B树**
    - 多叉；
    - 左小右大；
    - 每层子节点数>1，且<=M（M>=2，M为最大叉数）；
    - 子节点的关键字数量大于等于ceil(M/2)-1个且小于等于M-1；
    - 所有叶子节点在同一层，且具有NIL节点。
13. **B+树**
    - 有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
    - 所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。
    - 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。
    - 优势：单一节点存储更多的元素，使得查询的IO次数更少；所有查询都要查找到叶子节点，查询性能稳定；所有叶子节点形成有序链表，便于范围查询。
14. **B*树**
15. **红黑树**
    - 是二叉查找树
    - 节点是红色或黑色。
    - 根是黑色。
    - 所有叶子都是黑色（叶子是NIL节点）。
    - 从每个叶子到根的所有路径上不能有两个连续的红色节点。
    - 从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点（简称黑高）。
    - 保存了父节点指针。
    - 平衡树是为了解决二叉查找树退化为链表的情况，而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。
16. **map,unordered_map底层原理**
    - map:key有序，可自定义key排序；底层用红黑树；
    - unordered_map:无序；底层用哈希表，查找速度快
17. **unordered_map使用自定义类型的键需要做哪些操作**
    - 自定义hash函数
    - 自定义等比函数std::equal_to<key>，或重载==操作符以确保没有重复值（std::equal_to<key>内部是通过==实现的）；
18. **static_cast,dynamic_cast,const_cast，reinterpret_cast**
    - static_cast:任何编写程序时能够明确的类型转换都可以使用static_cast(除了底层const);不提供运行时检查；可以转换void*为原来的指针类型。
    - dynamic_cast:运行时类型检查；可将指针转为void*；用于将基类指针或引用安全地转为派生类指针或引用，基类至少含有一个虚函数（当想用基类指针或引用执行某个派生类操作，但该操作不是虚函数）；可用于菱形继承指定上行转换路径。
    - const_cast：只能改变运算对象的底层const。如果对象是一个常量，转换后执行写操作是未定义的行为。
    - reinterpret_cast:在编译期完成，可以转换任何类型的指针，所以极不安全。
19. **什么是多态**
    - 多态即多种形态。
    - 静态多态：函数重载、静态类型转换等。
    - 动态多态：继承、虚函数。
    - 多态的核心思想是数据抽象、继承、动态绑定。
20. **什么是面向对象**
    - 是一种对现实世界理解和抽象的方法
    - 将一组数据结构和操作组成一个对象，将相同的对象抽象成类，通过类的封装隐藏内部实现细节，通过继承实现特化，通过多态实现动态分派。
21. **虚继承**
    - 解决菱形继承问题，只保存一份虚基类的子对象。
22. **禁止继承** 
    - 在类名后加上final关键字。
23. **模板** 
24. **c++11新特性**
25. **c++线程**


